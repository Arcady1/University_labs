/* Разработать объектно-ориентированную программу для числовой игры, где 2 игрока должны поочередно 
наращивать сумму, достигнутую на предыдущем ходе противника, выбирая числовое приращение, которое не 
превышает заданной фиксированной величины N. Игра должна продолжаться, пока значение суммы, набранной 
обоими игроками, 
меньше заданной величины S>N. Победителем считается игрок, который на своем ходе смог первым набрать 
требуемую сумму M. Игра должна быть реализована в варианте, когда двумя противниками являются компьютер и человек, которому 
предоставлено право первого хода. Человек может делать любые допустимые ходы, сообщая величину приращения суммы 
через стандартный ввод. При любой ошибке ввода сумма автоматически увеличивается на N, и ход передается 
компьютеру. Компьютер должен действовать по выигрышной стратегии, согласно которой остаток до предельной суммы 
S после каждого его хода должен быть кратен (N+1). Если выигрышный ход сделать невозможно, компьютер должен 
повторить ход человека. В любом случае величина приращения суммы на ходе компьютера должна отображаться через 
поток стандартного вывода. Исходными данными для любой партии игры являются значение суммы S, которую должны 
набрать игроки, и предельная величина N ее приращения за 1 ход. Эти параметры должны передаваться программе 
через аргументы командной строки ее вызова. Каждый ход должен сопровождать запрос, который отображает текущую 
величину суммы и идентифицирует игрока, чей ход ожидается в данный момент. Партию игры должно завершать 
диагностическое сообщение, которое идентифицирует ее итоговый результат. При разработке программы необходимо 
реализовать производные классы игроков с виртуальной функцией хода, которые наследуют интерфейс игры и доступ 
к значению набранной суммы от абстрактного базового класса. */

#include <iostream>
#include <stdlib.h>
using namespace std;

// класс куча
class Sum
{
private:
    int size = 0; // размер набранной суммы
public:
    Sum(int s) : size(s){}; // конструктор инициализации
    int get(int n = 0)
    {
        size += n;
        return size; // возврат текущего размера суммы
    };
};

// абстрактный базовый класс
class Gambler
{
protected:
    Sum *sum;         // указатель на набранную сумму
    const int N;      // максимальное числовое приращение
    const char *name; // имя игрока
public:
    Gambler(Sum &s, int l) : N(l) { sum = &s; }; // конструктор инициализации
    int query();                                 // функция запроса хода; возвращает размер текущей суммы
    virtual int move(Sum) = 0;                   // виртуальная функция хода
    virtual ~Gambler(){};                        // виртуальный деструктор
};

int Gambler::query()
{
    cout << "Sum = " << sum->get() << " " << name << " > ";
    return sum->get();
}

// класс игрока
class Man : public Gambler
{
public:
    Man(Sum &s, int l, const char *n) : Gambler(s, l) { name = n; }; // конструктор инициализации
    virtual int move(Sum) override;
};

// класс компьютера
class Pc : public Gambler
{
public:
    Pc(Sum &s, int l, const char *n) : Gambler(s, l) { name = n; }; // конструктор инициализации
    virtual int move(Sum) override;
};

int Man::move(Sum S)
{
    int g;
    cin >> g;               // приращение, добавленное игроком
    if ((g < 1) || (g > N)) // при ошибке ввода числа человеком
        g = N;

    return sum->get(g);
}

int Pc::move(Sum end)
{
    int S = end.get();
    int x = 1;          // величина хода (приращение)
    int s = sum->get(); // текущий остаток суммы

    // if ((s = (sum->get())) == 1)
    // {
    //     s = sum->get(1);
    // }
    while (((S - (s + x)) % (N + 1)) != 0) // находим нужный остаток суммы
    {
        // printf("\n$ %d $\n", (S - s - x));
        if (x > N)
        {
            printf("!");
            // ИСПРАВИТЬ НА ХОД, СДЕЛАННЫЙ ЧЕЛОЕКОМ!!!
            x = 1;
            break;
        }
        else
        {
            x++;
        }
    }
    // printf("$ %d $\n", (S - s - x));

    sum->get(x); // увеличиваем сумму на величину хода Pc
    cout << x << endl;
    return (sum->get());
    // если sum == 0, тогда +1
    // иначе, если не работает алгоритм, + предвдущий шаг человека

    // int rest = 0; // остаток суммы,который должен остаться после хода компьютера
    // int x = 0;    // величина выигрышной стратегии
    // int s = 0;    // текущий остаток суммы

    // if ((s = (sum->get())) == 1)
    // {
    //     s = sum->get(1);
    // }
    // while ((rest = (x * N + x + 1)) <= s) // находим нужный остаток суммы
    // {
    //     x++;
    // }
    // if ((rest > s) || (rest == s)) // если остаток привышает количество суммы, то возвращаемся на оидн ход назад
    // {
    //     rest = (x - 1) * N + x;
    // }
    // sum->get(s - rest); // уменьшаем сумму на разность между текущим остатком суммы и желаемым остатком
    // cout << s - rest << endl;
    // return (sum->get());
}

int main(int argc, char *argv[])
{
    int i = 0;                                                                                     // отслеживание ходов игрока и компьютера, для определения очередности ходов
    Sum s(atoi(argv[1]));                                                                          // максимальное значение суммы, которое должны набрать игроки
    Sum cur_sum = 0;                                                                               // начальная сумма, равная 0
    Gambler *g[] = {new Pc(cur_sum, atoi(argv[2]), "Pc"), new Man(cur_sum, atoi(argv[2]), "Man")}; // указатели на объекты игроков; argv[2] - предельная величина приращения суммы (N) за 1 ход

    while (g[i]->query() < s.get()) // пока размер суммы меньше заданной величины s
    {
        g[i]->move(s); // сам ход
        if (++i > 1)   // смена хода
            i = 0;
    }
    cout << "Winner\n";
    delete g[0];
    delete g[1];
    return 0;
}